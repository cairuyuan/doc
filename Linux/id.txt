进程id		pid_t		getpid()
线程id		pthread_t	pthread_self()	-->应该有自己的id，在task中的那个

该线程的真实pid，称为tid，使用syscall得到 * 
= syscall(SYS_gettid); 
= (long int)syscall(224)
= (long int)gettidv1()

在多线程执行的情况下调用fork()函数，仅会将发起调用的线程复制到子进程中。不能同时创建出于父进程一样多线程的子进程。其他线程均在子进程中立即停止并消失，并且不会为这些线程调用清理函数以及针对线程局部存储变量的析构函数。
1. 虽然只将发起fork()调用的线程复制到子进程中，但全局变量的状态以及所有的pthreads对象（如互斥量、条件变量等）都会在子进程中得以保留，这就造成一个危险的局面。例如：一个线程在fork()被调用前锁定了某个互斥量，且对某个全局变量的更新也做到了一半，此时fork()被调用，所有数据及状态被拷贝到子进程中，那么子进程中对该互斥量就无法解锁（因为其并非该互斥量的属主），如果再试图锁定该互斥量就会导致死锁，这是多线程编程中最不愿意看到的情况。同时，全局变量的状态也可能处于不一致的状态，因为对其更新的操作只做到了一半对应的线程就消失了。fork()函数被调用之后，子进程就相当于处于signal handler之中，此时就不能调用线程安全的函数（用锁机制实现安全的函数），除非函数是可重入的，而只能调用异步信号安全（async-signal-safe）的函数。fork()之后，子进程不能调用：
malloc(3)。因为malloc()在访问全局状态时会加锁。
任何可能分配或释放内存的函数，包括new、map::insert()、snprintf() ……
任何pthreads函数。你不能用pthread_cond_signal()去通知父进程，只能通过读写pipe(2)来同步。
printf()系列函数，因为其他线程可能恰好持有stdout/stderr的锁。
除了man 7 signal中明确列出的“signal安全”函数之外的任何函数。

2. 因为并未执行清理函数和针对线程局部存储数据的析构函数，所以多线程情况下可能会导致子进程的内存泄露。另外，子进程中的线程可能无法访问（父进程中）由其他线程所创建的线程局部存储变量，因为（子进程）没有任何相应的引用指针。

推荐在多线程程序中调用fork()的唯一情况是：其后立即调用exec()函数执行另一个程序，彻底隔断子进程与父进程的关系。由新的进程覆盖掉原有的内存，使得子进程中的所有pthreads对象消失。

 对于那些必须执行fork()，而其后又无exec()紧随其后的程序来说，pthreads API提供了一种机制：fork()处理函数。利用函数pthread_atfork()来创建fork()处理函数。pthread_atfork()声明如下：
#include <pthread.h>

// Upon successful completion, pthread_atfork() shall return a value of zero; otherwise, an error number shall be returned to indicate the error.
// @prepare 新进程产生之前被调用
// @parent  新进程产生之后在父进程被调用
// @child   新进程产生之后，在子进程被调用
int pthread_atfork (void (*prepare) (void), void (*parent) (void), void (*child) (void));
该函数的作用就是往进程中注册三个函数，以便在不同的阶段调用，有了这三个参数，我们就可以在对应的函数中加入对应的处理功能。

fork()函数的调用会导致在子进程中除调用线程外的其它线程全都终止执行并消失，因此在多线程的情况下会导致死锁和内存泄露的情况。在进行多线程编程的时候尽量避免fork()的调用


1：父进程通过fork创建了子进程。子进程不但继承了父进程整个地址空间的副本，也继承了所有的互斥量，读写锁和条件变量的状态，如果父进程包含多个线程，子进程在fork返回之后，如果不是紧接着使用exec的话，就要清理锁状态。
2：pthread_atfork最多可以安装三个帮助清理锁的函数。prepare函数将在fork创建子进程之前被调用，通常可以用来获取进程中的所有锁；parent在fork创建子进程后返回前在父进程中被调用，可以用来释放父进程中的锁；child在fork创建子进程后fork返回前在子进程中被调用，可以用来释放子进程中的锁。给这三个参数传递NULL，表示不调用该函数。



  在Unix进程中涉及多个用户ID和用户组ID，包括如下：

1、实际用户ID和实际用户组ID：标识我是谁。也就是登录用户的uid和gid，比如我的Linux以simon登录，在Linux运行的所有的命令的实际用户ID都是simon的uid，实际用户组ID都是simon的gid（可以用id命令查看）。

2、有效用户ID和有效用户组ID：进程用来决定我们对资源的访问权限。一般情况下，有效用户ID等于实际用户ID，有效用户组ID等于实际用户组ID。当设置-用户-ID（SUID）位设置，则有效用户ID等于文件的所有者的uid，而不是实际用户ID；同样，如果设置了设置-用户组-ID（SGID）位，则有效用户组ID等于文件所有者的gid，而不是实际用户组ID。

 

以上来自：APUE（《高级UNIX环境编程》）