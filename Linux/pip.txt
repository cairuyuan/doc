有名管道
创建    
    int mkfifo (_const char *_path,_mode_t _mode);
打开
    open(const char *path, O_RDONLY);//1  
    open(const char *path, O_RDONLY | O_NONBLOCK);//2  
    open(const char *path, O_WRONLY);//3  
    open(const char *path, O_WRONLY | O_NONBLOCK);//4  

除非有O_NONBLOCK，否则第一个open会被阻塞，直到其他进程open同一个管道


ssize_t read  (int _fd,void *_buf,size_t _nbytes);
ssize_t write (int _fd,_const void *_buf,size_t _n);
        


        int pipefd[2];
        pipe(pipefd)
使用时，在pipefd[0]读取，在pipefd[1]写入，他们是指向同一个文件，不同用处的文件描述符

pipefd[0] refers to the read end of the pipe. 
pipefd[1] refers to the write end of the pipe. 

无名管道常用于父子进程中,  可简单分为单向管道流模型和双向管道流模型.  其中,  单向管道流根据流向分为从父进程流向子进程的管道和从子进程流向父进程的管道. 

         
如果希望打开管道写端，则需要另一个进程打开管道读端，整个程序才能正常进行；如果只打开有名管道的一端，则系统将暂时阻塞打开进程，直到有另一个进程打开该管道的另一端，当前进程才会继续执行。


管道实际上是固定大小的缓冲区，通常为一个页4K

当官到满了之后，随后的写入会被阻塞，当管道空了之后，随后的读取也会被阻塞

从管道读数据是一次性操作，数据一旦被读，它就从管道中被抛弃，释放空间以便写更多的数据。

在 Linux 中，管道的实现并没有使用专门的数据结构，而是借助了文件系统的file结构和VFS的索引节点inode。通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的。
  
  
  
  管道作为通讯工具时，数据要在两个进程中都可见。通常是在主进程中创建，子进程继承得到
  
  用于线程间通信也可以，使用匿名管道足够，pipe
  
  
  
管道是进程之间的一种单向交流方法,  要实现进程间的双向交流,  就必须通过两个管道来完成.  双向管道流的创立过程如下: 

    (1)  创建管道,  返回两个无名管道文件描述符 fildes1 和 fildes2: 

    (2)  创建子进程,  子进程中继承管道 fildes1 和 fildes2. 

    (3)  父进程关闭只读文件描述符 fildes1[0],  只写描述符 fildes2[1] 

    (4)  子进程关闭只写文件描述符 fildes1[1],  只读描述符 fildes2[0] 

    创建的结果如下: 

              父进程  --写--> fildes1[1] --管道--> fildes1[0] --读-->  子进程 

              父进程  <--读-- fildes2[0] <--管道-- fildes2[1] <--写--  子进程 




