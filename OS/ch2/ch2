1
block run  able
B --> R 可能，键盘将阻塞中的程序唤醒并立即运行
A --> B 不占有CPU就会一直保持原状态，没有cpu不会执行指令。A ready process cannot do I/O or anything else that might block it. Only a running process can block



2
需要
1 code计数器
2 各寄存器的上一次状态



3
中断程序需要进行上下文切换，主要是寄存器和其他的一些变量。C等高级语言无法访问这些变量



4
如果用户态的程序被中断，进入核心态，就会从用户态的stack切换到内核态的stack（通常1或2个page）。用户态的stack指针以及其他上下文的状态量会被保存在内核态stack中。当执行iret返回时，这些都会恢复。如果在中断中被额外终端，就不需要保存stack，无论是用户态（已经保存了），还是内核栈（正在而且将要使用的）。用户stack通过ulimit -s 一般8192

分开特权数据和普通进程数据
  避免仅仅因为用户程序的栈溢出就崩溃系统
  避免有人从用户栈中的特权数据找到其他进程寻行的信息
  
fork族 --> do_fork --> copy_process --> dup_task_struct会创建内核栈

 

5
单个程序执行需要20min，其中10min占有cpu
顺序执行需要40min

并行执行，整体利用率1-0.5×0.5 = 0.75。这表示75%的时间CPU执行的，单个占0.375
于是10/0.375 = 26.67min

这个模型的前提是两个事物是独立的。极限的情况
二者等待的资源相同又必须独占使用，那么和顺序执行一样
如果二者等待的资源完全不同，时机不重叠，那么用20min即可



6
进程之间不能共享打开的文件资源。
文件服务器可能要对单个文件作多种



7
一旦调用fork，开始时代码段相同，数据段和堆栈段使用写时复制，分开.再调用exec时，三个段都会更换内容。

如果全部复制父进程，子进程复制一份被阻塞的线程。这属于父进程的其他线程中出现fork，导致父进程中的阻塞线程也被复制。

单线程不会，因为如果这个唯一的线程被阻塞，那么他就不会执行无法fork，如果他有cpu去fork，他就不处于阻塞状态。

















