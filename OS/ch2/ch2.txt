1
block run  able
B --> R 可能，键盘将阻塞中的程序唤醒并立即运行
A --> B 不占有CPU就会一直保持原状态，没有cpu不会执行指令。A ready process cannot do I/O or anything else that might block it. Only a running process can block



2
需要
1 code计数器
2 各寄存器的上一次状态



3
中断程序需要进行上下文切换，主要是寄存器和其他的一些变量。C等高级语言无法访问这些变量



4
如果用户态的程序被中断，进入核心态，就会从用户态的stack切换到内核态的stack（通常1或2个page）。用户态的stack指针以及其他上下文的状态量会被保存在内核态stack中。当执行iret返回时，这些都会恢复。如果在中断中被额外终端，就不需要保存stack，无论是用户态（已经保存了），还是内核栈（正在而且将要使用的）。用户stack通过ulimit -s 一般8192

分开特权数据和普通进程数据
  避免仅仅因为用户程序的栈溢出就崩溃系统
  避免有人从用户栈中的特权数据找到其他进程寻行的信息
  
fork族 --> do_fork --> copy_process --> dup_task_struct会创建内核栈

 

5
单个程序执行需要20min，其中10min占有cpu
顺序执行需要40min

并行执行，整体利用率1-0.5×0.5 = 0.75。这表示75%的时间CPU执行的，单个占0.375
于是10/0.375 = 26.67min

这个模型的前提是两个事物是独立的。极限的情况
二者等待的资源相同又必须独占使用，那么和顺序执行一样
如果二者等待的资源完全不同，时机不重叠，那么用20min即可



6
进程之间不能共享打开的文件资源。
文件服务器可能要对单个文件作多种



7
一旦调用fork，开始时代码段相同，数据段和堆栈段使用写时复制，分开.再调用exec时，三个段都会更换内容。

如果全部复制父进程，子进程复制一份被阻塞的线程。这属于父进程的其他线程中出现fork，导致父进程中的阻塞线程也被复制。

单线程不会，因为如果这个唯一的线程被阻塞，那么他就不会执行无法fork，如果他有cpu去fork，他就不处于阻塞状态。



8
应该使用核心线程，有力于并发

web服务器往往会在短时间内收到大量的请求。如果使用用户线程，工作线程被read阻塞后，整个程序就会被阻塞，分派线程也无法工作分派新任务，如果使用内核线程，单个工作线程被阻塞，不会影响分配线程



9
满足并发，在整体上提升web服务器响应速度。对于有较多IO等待的服务
对于完全是CPU密集型的服务，不仅程序设计复杂，而且运行效率也没有多大提升



10
？这些寄存器变量是属于每个线程“私有”的状态/属性



11
线程通常是同一目的工作的，对资源是协作而不是竞争，编写者可以选择合适的时机，选择线程自动放弃或获得CPU， 以获得整体的高性能



12
系统利用时钟中断维持系统时间、促使环境的切换，以保证所有进程共享CPU；利用时钟中断进行记帐、监督系统工作以及确定未来的调度优先级等工作

用户级别的线程
不应该，CPU中断的影响对象应该是线程级别，CPU对时间的划分也是针对进程的。除非是总进程要被时间中断，而此时进程内部正在占有cpu的线程就恰好被时间中断。

内核级别的线程
可以被时间中断，内核线程更类似进程，若不能中断，就退化成非抢占式。。。

内核进程和 普通进程一样，可以被调度，也可以被抢占
内核线程和普通的进程间的区别在于内核线程没有独立的地址空间，（实际它的mm指针被设置为NULL）
内核线程也只能由其他内核线程创建

每个线程都拥有唯一属于自己的task_struct，所以在内核中，它看起来就像是一个普通的进程



13
意思：
2/3的概率在缓存中，15min
1/3的概率在磁盘中，90min

单线程
2/3 × 15 + 1/3 × 90 = 40min
1000/40=25
多线程
磁盘等待部分都可以另外使用，1000/15 = 66.7



14
优点
不需要陷入内核从而切换上下文，只修改若干寄存器，速度更快

缺点
组塞会导致整个进程组塞



15
可以在创建新线程前检查前一个线程留下/返回的信息，确认前一个已经退出，再创建新的

现成的方法是创建线程调用jion（刚才创建的线程）



16？



17？



18
线程进入内核前设置警报定时器，如果阻塞就由定时器讲控制返回给调度/线程包，



19
与系统有关
有的系统实现了抢占式的用户级线程，则会出现，否则不会出现

如果多个核心执行，并且按照优先级策略要求，则也会出现



20
？


21
用户级线程每个线程独立使用栈，内核线程使用独立的栈
如果使用同一个栈，则同时执行会越界，



22
竞争条件：读写共享数据，最后的结果取决于运行时序
看上去没有什么变化，不理解这一句“没有同时事件”有何特别？



23
全局变量turn是全局唯一的，两个线程0、1在不同的核心上执行时，turn仍然控制有效



24
Peterson算法是一个实现互斥锁的并发程序设计算法，可以控制两个进程访问一个共享的单用户资源而不发生访问冲突。Pi访问共享资源,flag和turn是全局
//flag[] is boolean array; and turn is an integer
flag[0]   = false;
flag[1]   = false;
turn;

P0: flag[0] = true;
    turn = 1;
    while (flag[1] == true && turn == 1)；当另一方在临界区，自己正想访问临界区，等
    // critical section
    flag[0] = false; // end of critical section
    
P1: flag[1] = true;
    turn = 0;
    while (flag[0] == true && turn == 0)；
    // critical section
    flag[1] = false; // end of critical section

turn用于检查是哪个进程进入临界区

非抢占式（Nonpreemptive） 让进程运行直到结束或阻塞的调度方式，抢占式（Preemptive） 允许将逻辑上可继续运行的在运行过程暂停的调度方式

有效
如果是不可抢占式的，会出问题，比如在flag[0/1]=false之前的临界区出现阻塞，另一个进程开始运行，就会出现while死循环（不可抢占，会一直运行）



25
信号量用于累计唤醒次数，一次唤醒，对应一次资源的释放
down操作减少信号量，表示资源消耗，up表示一次唤醒。两种操作要保证原子性
up和down前后，关开中断



26
不仅希望对信号量的访问是"阻塞"的，而且希望信号量的值非负时也能"阻塞"

M用于互斥访问，B用于阻塞当前访问，都是二元信号量
UP                            DOWN
  DOWN(M)                       DOWN(M)
  counter += 1                  counter -= 1
  if counter < 0                UP(M)
     UP(B)                      if (counter < 0 )
  UP(M)                            DOWN(B)

M是是否在临界区的标识，UP操作表示一次资源的释放或一次唤醒，



27
屏障是？？？



28
用户级的线程组塞，导致进程内所有线程都阻塞



29
管程可以克服信号量操作分散、难以控制、读写维护困难的问题，将共享资源/变量和对他们的操作集中在一个模块中。管程通常是用于管理资源的，通过管程的机制来访问资源

为了保证共享变量的数据一致性，管程应互斥使用，确保同一时刻只有一个线程可以对资源进行访问
管程中有进程等待队列和相应的等待和唤醒操作
使用wait，线程使自己阻塞让出控制权   生产者发现已无空槽，消费者发现已无可用的槽
发出signal的线程，会立即退出管程    生产者发现已有一个满槽，消费者发现已经有一个空槽

waituntil x<0 or y+z<n
：实现的哀家过高，每一次都需要重新计算谓词表达式的值



30
使用消息传递。消息为订单、食物和袋子。在 UNIX 中,该4个进程通过管道连接。



31
？



32
nT



33
人工可以分析代码，发现其中请求IO的地方。但是IO的具体是否执行，次数等可能收到具体执行时环境影响。人工只能分析出大概

运行时可以通过记录过的运行行为来估算



34
对于管道中的多进程，普通的父进程可以将数据流的信息传递给OS，OS可以确定哪个进程可以向阻塞的进程提供输出。



35
Q = infinit
一个进程永远执行，除非工作完成  T/(T+S)

Q > T
时间片用完前，进程已经需要阻塞  T/(T+S)

S < Q < T
正在运行时，时间用完需要切换 T/(T+ST/Q) --> Q/(Q+S)

Q = S
50%

Q --> 0
时间片为0，CPU都用于切换，0%



36
排序



37
a）轮转法
各作业结束时间为：
    A   B   C   D   E
第  30  28  10  18  24 分钟     
平均周转时间 （30+28+10+18+24）/5 = 22

b）优先级调度
各作业结束时间为：
    A   B   C   D   E
第  24  26  6   30  14 分钟 
平均周转时间 （24+26+6+30+14）/5 = 18.8

c）先来先服务
    A   B   C   D   E
第  10  16  18  22  30 分钟 
平均周转时间 （10+16+18+22+30）/5 = 19.2

d）最短作业优先
    A   B   C   D   E
第  30  12  2   6   20 分钟
平均周转时间 （30+12+2+6+20）/5 = 14


38
CTSS，优先级队列调度
高优先级会高频率运行，但是时间片短，运行后优先级下降，时间片加倍
获得时间片  1  2  4  8  16共需要5次调入



39




40
不是只和前面两次有关，每一次的估计都和之前每一次数据有关
40 30 35 25



41
i类型的时间发生周期为Pi，处理时间Ci,要使总 Pi/Ci < 1
35/50 + 20/100 + 10/200 + x/250 = 1
x = 12.5ms



42
内存不足



43
20/40 + 2 × 1/5 = 0.9 可以调度



44
分离的办法是将调度算法参数化，父进程通过参数设置影响调度程序

