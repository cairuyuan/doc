1
巧合
基址是一个段开始的地址号，界限是一个程序段的长度，标志一段程序的不同属性



2
读取4byte使用10ns，则读取1byte需要2.5ns，写1byte同样2.5ns，移动1byte总共5ns
2^27 * 5 * 10^(-9) = 671 msec
这是时间估计相对大了



3
可划分为2048个块，每个64KB
位图：2^27 / (n*8)
链表：2048 * (4 + 2 + 2) = 16KB



4
10	4	20	18	7	9	12	15
连续请求：12  10  9
首次适配：第2,  0,  3（仍按原序列编号）
最佳适配：第6， 0， 5
最差适配：第2， 3， 7
下一次适配：第2，3，5



5
坑爹的10进制，就按16进制算吧
4K = 01000 , 8K = 02000
20000：
4K：20	0
8K: 10	0

32768
4K:	32  768
8K: 16 	768

60000
4K: 60  0
8K: 30  0



6
制作的MMU。。。



7
每次M应该至少跨越一个页表，int为32bit时，M至少为128，N任意

如果N小于256K，执行一遍后所有的TLB都加载而且足以覆盖数组，所以应该大于或等于256K。下一遍执行，TLB的最开始已经被替换了，需要重新加载（最低端的TLB隔得时间最长），M不变



8
最坏情况单个进程占有了全部内存（还不够），其他的进程都被交换到磁盘：
(n-1)*v+v-r

。。。？



9
32位地址数的幂为32，页面幂13，页表项2exp(19)个
2exp(19) * 100ns /100ms = 0.0524



10
地址空间的编址都是按照虚地址来的，超过实际硬件的部分，可能位于交换文件中。。。

48-12 = 36， 所以有2E36个表项

多少个TLB项不影响。

指令能放入一个页中，所以执行不会发生指令缓存不命中情况

数据都是在连续的页中，访问也是一次的，所以只有访问完一个页中的数据，再下一个时，不能命中。



11
多级页表减少了页表的存储规模

一个页的大小为2E12=4KB，一个一级表项含有16K = 2E14个页，38-12-14=12位.



12
32-9-11 = 12，页面为4K = 2E12

2E20个页面



13
页面数为总空间/页面大小，所以只和d有关系，和几级页表以及每一级的规模没有关系



14
32-12=20，2E20个表项
2E11个表项



15
设命中率为a，平均开销为：
a*1+(1-a)*5 = 2
a = 0.75



16
R，FIFO第二次机会法(频繁操作链表)，-->时钟页面置换算法



17
associative



18
48-13=35，2E35个表项



19



20
不能
程序的行为在编译阶段不能完全确定，



21
三者的应用效果一样，每次淘汰的是同一页面。都不能起到预测命中的效果

固定500个页面，只是用一个变化位



22
页是虚拟存储区，叶框是对应的物理存储区。有8个虚拟页，只有4个页的内存。

0  1  7  2  3  2  7  1  0  3
FIFO：6
LRU ：7



23
D



24
老化算法，为每一个页面（集）设置一个计数器。如果本次时钟期间有访问，则将计数左移一位，并将最高位置1，否则左移置0。缺页时，淘汰计数值最小的一个。

01101110
01001001
00110111
10001011



25
what



26
工作集页面置换算法，找出一个不在工作集中页面并淘汰。缺页发生时，首先检查R位，如果为1（属于工作集，不应删除），就更新时间。如果0，再计算生存时间，如果大于阈值t就可以淘汰。<-- 需要扫描整个页表


工作集时钟页面置换算法，时钟法类似

当前时间2204，已生存991，可以移出，1000时不可移出。



27
循道20ms、
？



28
2
3
1
2



29
B的缺页少一些，A是按列访问，每2个元素就要跳过1个页，很容易就发生缺页



30
磁鼓？



31
4K的页面需要8+5+4 = 17个页面，不够用
512的页面，64+33+31=128个页面，够用



32
现在许多程序的代码段，都是有共享的



33
15000*2ms = 30s，实际运行60-30 = 30s

缺页平均间隔为每30s/15000发生一次缺页，内存加倍后，每运行2*30/15000发生一次中断，缺页引起时间：2ms * 30/(60/15000) = 15s。总的时间45s



34



