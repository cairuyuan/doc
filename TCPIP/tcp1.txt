1
应用数据被分割成T C P认为最适合发送的数据块，长度不变

当T C P发出一个段后，它启动一个定时器，超时重传

当T C P收到发自T C P连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒，窗口

保持它首部和数据的检验和

对收到的数据进行重新排序，

丢弃重复的数据

提供流量控制



2
T C P对字节流的内容不作任何解释，U n i x的内核来说，它无法区分一个二进制文件与一个文本文件。



3
TCP的半关闭
我已经完成了数据传送，因此发送一个文件结束（ F I N）给另一端，但我还想接收另一端发来的数据，直到它给我发来文件结束（F I N）

半关闭？一个例子是U n i x中的r s h



4
一个报文段发往基准的连接（ referenced connection）出现错误， T C P都会发出一个复位报文段（这里提到的“基准的连接”是指由目的I P地址和目的端口号以及源I P地址和源端口号指明的连接。这就是为什么RFC 793称之为插口）。

RST表示位设置1


产生复位的一种常见情况是当连接请求到达时，目的端口没有进程正在听

发送一个复位报文段而不是F I N来中途释放一个连接。有时称这为异常释放（abortive release）。



5
如果一方已经关闭或异常终止连接而另一方却还不知道，我们将这样的T C P连接称为半打开（H a l f - O p e n）的



6
两个不同的主机使用telnet链接到服务器
是n e t s t a t程序的输出行：

tcp 0 0 140.252.13.33.23 140.252.13.65.1030 ESTABLISHED
tcp 0 0 140.252.13.33.23 140.252.13.65.1029 ESTABLISHED
tcp 0 0 *.23 *.* LISTEN

它们的本地端口号均为2 3。由于它们的远端端口号不同，这不会造成冲突

因为每个Te l n e t客户进程要使用一个外设端口，并且这个外设端口会选择为主机（ s l i p）当前未曾使用的端口，因此它们的端口号肯定不同。

T C P使用由本地地址和远端地址组成的4元组：目的I P地址、目的端口号、源I P地址和源端口号来处理传入的多个连接请求。



7
当服务器正处于忙时， T C P是如何处理这些呼入的连接请求，此时无法立即处理请求

1) 正等待连接请求的一端有一个固定长度的连接队列，该队列中的连接已被T C P接受（即三次握手已经完成），但还没有被应用层所接受。注意区分T C P接受一个连接是将其放入这个队列，而应用层接受连接是将其从该队列中移出。

2) 应用层将指明该队列的最大长度，这个值通常称为积压值( b a c k l o g )。它的取值范围是0 ~ 5之间的整数，包括0和5（大多数的应用程序都将这个值说明为5）

3) 当一个连接请求（即S Y N）到达时，T C P使用一个算法，根据当前连接队列中的连接数来确定是否接收这个连接。

4) 如果对于新的连接请求，该T C P监听的端点的连接队列中还有空间，T C P模块将对S Y N进行确认并完成连接的建立。但应用层只有在三次握手中的第三个报文段收到后才会知道这个新连接时。另外，当客户进程的主动打开成功但服务器的应用层还不知道这个新的连接时，它可能会认为服务器进程已经准备好接收数据了（如果发生这种情况，服务器的T C P仅将接收的数据放入缓冲队列)。

5) 如果对于新的连接请求，连接队列中已没有空间， T C P将不理会收到的S Y N。也不发回任何报文段（即不发回R S T）。如果应用层不能及时接受已被T C P接受的连接，这些连接可能占满整个连接队列，客户的主动打开最终将超时。



8
在relogin这样程序中，每一个字节都会独立发出。
通常T C P在接收到数据时并不立即发送A C K；相反，它推迟发送，以便将A C K与需要沿该方向发送的数据一起发送（有时称这种现象为数据捎带A C K）。绝大多数实现采用的时延为200 ms，也就是说，T C P将以最大200 ms 的时延等待是否有数据一起发送。



9
对于小的报文段
接收方使用经受时延的确认方法来判断确认是否可被推迟发送，以便与回送数据一起发送。这样通常会减少报文段的数目，尤其是对于需要回显用户输入字符的R l o g i n会话。

在较慢的广域网环境中，通常使用N a g l e算法来减少这些小报文段的数目。这个算法限制发送者任何时候只能有一个发送的小报文段未被确认



10
TCP协议使用“重新发送与正向ACK”来保证数据传输的可靠性。

发 送方将等待一段时间，如果没有收到其发送的数据包的ACK确认信息，发送方就要重新发送

TCP窗口尺寸可以控制在“已发送但是没有确认”的状态下能够容纳多少个数据包，接收方就是控制窗口大小的那一方

如果最后的窗口尺寸是 “0”，就不能发送任何数据，发送者将发出一个探测信号以搞清这个窗口什么时间再次打开。如果发送方从来没有收到ACK信息，它就一直不断地重试，直到定时器过期。

窗口尺寸在TCP头中是一个16位字段。如果要窗口尺寸(按字节计算)大于16位可以表示的容量（2的16次方个字节），还可以使用一个名为“窗 口缩放”的TCP协议选项。这个选项允许窗口尺寸乘以比例因子。

如果没有极大的窗口尺寸，TCP协议就就无法充分利用GB级别的高速连接。这也是我们需要 针对这些新的高速连接调整TCP参数的原因，



11
T C P通过在发送数据报文时设置一个超时定时器来解决这种问题，如果在定时器溢出时还没有收到来自对端对发送报文的确认，它就重传该数据报文

当T C P超时并重传时，它不一定要重传同样的报文段。相反， T C P允许进行重新分组而发送一个较大的报文段

从发出数据包到第一次TCP重传开始，RFC中这段时间间隔称为retransmission timeout，缩写做RTO

RTT：对往返时间的当前估计值。当一个数据段被发送出去后，TCP 启动定时器，如果在定时器过期之前确认数据段回来的话，则 TCP 测量一下这次确认所花的时间 M，然后根据如下公式更新 RTT。   RTT = aRTT + (1-a)M   其中 a 是平滑因子，典型的值是0.9这个公式的意思就是说，旧的RTT 占有90%的权重，新的往返时间占有 10% 的权重(RTT还有其他的估计算法)
 
RTO 的计算公式：RTO = RTT + 4D.
D是平滑的平均偏差：D   = aD + (1-a)|RTT-M|

现在的算法个能已经改进



12
上面的是初次重传时的RTO，如果重传后还没收到另一端的响应，下一次重传RTO则会指数增加，例如第一次重传RTO是1，之后分别2，4，8，16...。

TCP默认最多做15次重传。根据RTO(retransmission timeout)不同，最后一次重传间隔大概是13到30分钟左右。如果15次重传都做完了，TCP/IP就会告诉应用层说：“搞不定了，包怎么都传不过去！”

即使RTT很小（0.8ms），但是因为RTO有下限，最小必须是200ms；RTO最小值是内核编译是决定的，socket程序中无法修改，Linux TCP也没有任何参数可以改变这个值。

TCP报文重传的次数也根据系统设置的不同而有区分，有些系统，一个报文只会被重传3次，如果重传三次后还未收到该报文的确认，那么就不再尝试重传，直接reset重置该TCP连接，但有些要求很高的业务应用系统，则会不断的重传被丢弃的报文，以尽最大可能保证业务数据的正常交互。



13
RFC 675 - Specification of Internet Transmission Control Program, December 1974 Version 
RFC 793 - TCP v4 
RFC 1122 - includes some error corrections for TCP 
RFC 1323 - TCP-Extensions 
RFC 1379 - Extending TCP for Transactions―Concepts 
RFC 1948 - Defending Against Sequence Number Attacks 
RFC 2018 - TCP Selective Acknowledgment Options 
RFC 2988 - Computing TCP's Retransmission Timer 
RFC 4614 - A Roadmap for TCP Specification Documents 
RFC 5681 - TCP Congestion Control



14
拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载，拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。

发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口，另外考虑到接受方的接收能力，发送窗口可能小于拥塞窗口。

慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。当然收到单个确认但此确认多个数据报的时候就加相应的数值。所以一次传输轮次之后拥塞窗口就加倍。乘法增长


拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性规律缓慢增长。



15
无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法

慢开始门限ssthresh状态变量。ssthresh的用法如下：

当cwnd<ssthresh时，使用慢开始算法。

当cwnd>ssthresh时，改用拥塞避免算法。

当cwnd=ssthresh时，慢开始与拥塞避免算法任意



16
快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要使用捎带确认。

发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。



17
1.无连接VS面向连接
UDP是无连接的，TCP面向连接的，这个连接指的就是在运用TCP协议之前，必须先建立TCP连接，在数据传送完毕之后必须释放连接，通俗地将通信的双方知道彼此的存在这个连接是一个虚电路。

影响：

①因为要建立连接所以TCP有建立连接的“三次握手”，所以UDP在发送数据之前时延更加小。

②因为面向连接是端到端的通信，所以多播和广播就只能运用UDP协议。


2.尽最大努力交付VS可靠交付
影响：

①UDP不保证可靠交付，当发生丢包的时候不重传，并且不保证数据包按序到达。所以UDP数据报报头小，并且不用维护很多的定时器、连接状态表、算法。

②TCP提供可靠交付。保证数据包无差错、不丢失、不重复、并且按序到达。


3.面向报文VS面向数据流
UDP面向报文，发送方的UDP应用程序交下来的报文，在添加首部后就向下交付给IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说应用层交给UDP多大的报文，UDP就照样发送，即一次发送一个报文。

TCP面向字节流，TCP中的“流”指的是流入到进程或从进程流出的字节序列。面向字节流的含义是：虽然应用程序和TCP的交互式一次一个数据块（大小不等），但是TCP把应用程序交下来的数据看成仅仅是一连串的无结构字节流。所以TCP才有滑动窗口机制、Nagle算法等等。因此TCP并不保证发送的数据块和应用层交付的数据块相等，比如应用层交付了10个数据块，但是TCP将此10个数据块合并为4个数据块发送，这是出于效率的考虑，但是字节流是一样的。


4.TCP具有拥塞控制
拥塞控制是面向全局网络的，和应用程序没有太多的关系。



18
TCP通过让接收方指明希望从发送方接收的数据字节数（即窗口大小）来进行流量控制。如果窗口大小为 0会发生什么情况呢？这将有效地阻止发送方传送数据，直到窗口变为非0为止。
TCP不对ACK报文段进行确认， TCP只确认那些包含有数据的ACK报文段。
如果一个确认丢失了，则双方就有可能因为等待对方而使连接终止：接收方等待接收数据（因为它已经向发送方通告了一个非 0的窗口），而发送方在等待允许它继续发送数据的窗口更新。为防止这种死锁情况的发生，发送方使用一个坚持定时器 (persist timer)来周期性地向接收方查询，以便发现窗口是否已增大。这些从发送方发出的报文段称为窗口探查 (window  probe)。



19
TCP的保活定时器
　　 如果一个给定的连接在2小时内没有任何动作，那么服务器就向客户发送一个探查报文段。客户主机必须处于以下4个状态之一。

　　(1) 客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方的正常工作的。服务器在2小时内将保活定时器复位。

　　(2) 客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务器将不能收到对探查的响应，并在75秒后超时。总共发送10个探查，间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。

　　(3) 客户主机崩溃并已经重新启动。这是服务器将收到一个对其保活探查的响应，但这个响应是一个复位，使得服务器终止这个连接。

　　(4) 客户主机正常运行，但是从服务器不可达。



20
如果telnet的客户端，没有注销的情况下关机，就会在服务器端留下半连接。如果服务器正在等待数据，则会长时间的等待下去，保活定时器旨在服务器端检测到这种半连接

当系统被操作员关闭时，所有的应用进程也被终止（也就是客户进程），这会使客户的T C P在连接上发出一个F I N。接收到F I N将使服务器的T C P向服务器进程报告文件结束，使服务器可以检测到这个情况。

缺点
(1)在出现短暂差错的情况下，这可能会使一个非常好的连接释放掉；
(2)它们耗费不必要的带宽；
(3)在按分组计费的情况下会在互联网上花掉更多的钱。