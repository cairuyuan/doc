1
RFC 768 [Postel 1980] 是U D P的正式规范。

U D P不提供可靠性：它把应用程序传给I P层的数据发送出去，但是并不保证它们能到达
目的地。

端口号表示发送进程和接收进程。T C P端口号由T C P来查看，而U D P端口号由U D P来查看。T C P端口号与U D P端口号是相互独立的。如果T C P和U D P同时提供某种知名服务，两个协议通常选择相同的端口号。这纯粹是为了使用方便，而不是协议本身的要求。



2
U D P检验和覆盖U D P首部和U D P数据。

I P的检验和，它只覆盖I P的首部―并不覆盖I P数据报中的任何数据。U D P和T C P在首部中都有覆盖它们首部和数据的检验和。U D P的检验和是可选的，而T C P的检验和是必需的。

IP标志字段中有一个比特称作“不分片”位。如果将这一比特置1，I P将不对数据报进行分片。相反把数据报丢弃并发送一个I C M P差错报文




3
UDP和ARP之间的交互式用

这是不常被人注意到的一个细节，这是针对一些系统地实现来说的。当ARP缓存还是空的时候。UDP在被发送之前一定要发送一个ARP请求来获得目的主机的MAC地址，如果这个UDP的数据包足够大，大到IP层一定要对其进行分片的时候，想象中，该UDP数据包的第一个分片会发出一个ARP查询请求，所有的分片都辉等到这个查询完成以后再发送。事实上是这样吗？

结果是，某些系统会让每一个分片都发送一个ARP查询，所有的分片都在等待，但是接受到第一个回应的时候，主机却只发送了最后一个数据片而抛弃了其他，这实在是让人匪夷所思。这样，因为分片的数据不能被及时组装，接受主机将会在一段时间内将永远无法组装的IP数据包抛弃，并且发送组装超时的ICMP报文（其实很多系统不产生这个差错），以保证接受主机自己的接收端缓存不被那些永远得不到组装的分片充满。
